//Bruteforce Approach

class Solution {
    public int numDecodings(String str) {
        return numDecodingsHelper(str);
    }

    private int numDecodingsHelper(String str) {
        // Base case: If the string is empty, we have found one valid decoding
        if (str.isEmpty()) {
            return 1; // Return 1 for this valid decoding
        }

        int count = 0;

        for (int i = 0; i < str.length(); i++) {
            if (isValidPartition(str.substring(0, i + 1))) {
                count += numDecodingsHelper(str.substring(i + 1));
            }
        }

        return count;
    }

    private boolean isValidPartition(String str) {
        if (str.length() > 2) {
            return false; // If the length of the string is greater than 2, it's invalid
        }

        if (str.charAt(0) == '0') {
            return false; // Invalid if the number has a leading zero
        }

        int num = Integer.parseInt(str);

        return num >= 1 && num <= 26;
    }
}


//Improved Approach

class Solution {
    public int numDecodings(String str) {
        return numDecodingsHelper(str, 0);
    }

    private int numDecodingsHelper(String str, int start) {
        if (start == str.length()) {
            return 1;
        }

        int count = 0;

        for (int i = start; i < str.length(); i++) {
            if (isValidPartition(str, start, i)) {
                count += numDecodingsHelper(str, i + 1);
            }
        }

        return count;
    }

    private boolean isValidPartition(String str, int start, int end) {
        if ((end - start + 1) > 2) {
            return false;
        }

        if (str.charAt(start) == '0') {
            return false;
        }

        int num = Integer.parseInt(str.substring(start, end + 1));

        return num >= 1 && num <= 26;
    }
}


//Good Approach

class Solution {
    private int[] memo;

    public int numDecodings(String str) {
        memo = new int[str.length()];
        Arrays.fill(memo, -1);
        return numDecodingsHelper(str, 0);
    }

    private int numDecodingsHelper(String str, int start) {
        if (start == str.length()) {
            return 1;
        }

        if (memo[start] != -1) {
            return memo[start];
        }

        int count = 0;

        for (int i = start; i < str.length(); i++) {
            if (isValidPartition(str, start, i)) {
                count += numDecodingsHelper(str, i + 1);
            }
        }

        return memo[start] = count;
    }

    private boolean isValidPartition(String str, int start, int end) {
        if ((end - start + 1) > 2) {
            return false;
        }

        if (str.charAt(start) == '0') {
            return false;
        }

        int num = Integer.parseInt(str.substring(start, end + 1));

        return num >= 1 && num <= 26;
    }
}


//Better Approach

class Solution {
    private int[] memo;

    public int numDecodings(String str) {
        memo = new int[str.length()];
        Arrays.fill(memo, -1);
        return numDecodingsHelper(str, 0);
    }

    private int numDecodingsHelper(String str, int index) {
        if (index == str.length()) {
            return 1;
        }

        if (memo[index] != -1) {
            return memo[index];
        }

        int count = 0;

        /*
         * Check for single digit decoding (valid if the digit is not '0')
         * A single digit can only be decoded if it is between '1' and '9'
         */
        if (str.charAt(index) != '0') {
            count = numDecodingsHelper(str, index + 1);
        }

        /*
         * Check for double digit decoding
         * A double digit can be decoded if:
         * - The first digit is not '0'
         * - The number formed by the two digits is between 10 and 26
         */
        if (isValidPartition(str, index, index + 1)) {
            count += numDecodingsHelper(str, index + 2);
        }

        // Partitions longer than two digits are invalid since we only have mappings for 1 to 26

        return memo[index] = count;
    }

    private boolean isValidPartition(String str, int start, int end) {
        // Check if the end index exceeds the string length
        if (end == str.length()) {
            return false;
        }

        /*
         * Check for valid two-digit range (10 to 26)
         * Numbers between 10-19 are valid (no restrictions on the second digit)
         * Numbers between 20-26 are valid
         */
        if (str.charAt(start) == '1' || (str.charAt(start) == '2' && str.charAt(end) <= '6')) {
            return true;
        }

        return false; // Invalid partition if not in valid range
    }
}


//Optimal Approach

class Solution {
    public int numDecodings(String str) {
        // dp[i] represents the number of ways to decode the substring str[0..i-1]
        int[] dp = new int[str.length() + 1];

        dp[0] = 1; // Base case: There's one way to decode an empty string (doing nothing)

        /*
         * Initialize dp[1] based on the first character
         * If the first character is '0', there are no valid decodings, hence dp[1] = 0
         * Otherwise, if it's between '1' and '9', it's valid and dp[1] = 1
         */
        dp[1] = str.charAt(0) != '0' ? 1 : 0;

        for (int i = 2; i <= str.length(); i++) {
            // Single-digit decoding: Only valid if the current character (str[i-1]) is not '0'
            if (str.charAt(i - 1) != '0') {
                dp[i] = dp[i - 1];
            }

            // Double-digit decoding: Check if the substring from str[i-2] to str[i-1] forms a valid number (10-26)
            if (isValidPartition(str, i - 2, i - 1)) {
                dp[i] += dp[i - 2];
            }
        }

        return dp[str.length()]; // Return the number of ways to decode the entire string
    }

    private boolean isValidPartition(String str, int start, int end) {
        // Valid if the first digit is '1' (so it could be '10' to '19'), or the first digit is '2' and the second digit is <= '6' (to ensure it's '20' to '26')
        if (str.charAt(start) == '1' || (str.charAt(start) == '2' && str.charAt(end) <= '6')) {
            return true;
        }

        return false;
    }
}


//Aliter (Space optimised)

class Solution {
    public int numDecodings(String str) {
        int previous2 = 1;
        int previous1 = str.charAt(0) != '0' ? 1 : 0;

        for (int i = 2; i <= str.length(); i++) {
            int current = 0;
            if (str.charAt(i - 1) != '0') {
                current = previous1;
            }

            if (isValidPartition(str, i - 2, i - 1)) {
                current += previous2;
            }

            previous2 = previous1;
            previous1 = current;
        }

        return previous1;
    }

    private boolean isValidPartition(String str, int start, int end) {
        if (str.charAt(start) == '1' || (str.charAt(start) == '2' && str.charAt(end) <= '6')) {
            return true;
        }

        return false;
    }
}
