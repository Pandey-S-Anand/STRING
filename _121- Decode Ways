//Bruteforce Approach

//Using forward recursive approach

class Solution {
    public int numDecodings(String str) {
        return numDecodingsHelper(str, 0);
    }

    private int numDecodingsHelper(String str, int start) {
        if (start == str.length()) {
            return 1;
        }

        int count = 0;

        for (int i = start; i < str.length(); i++) {
            if (isValidPartition(str, start, i)) {
                count += numDecodingsHelper(str, i + 1);
            }
        }

        return count;
    }

    private boolean isValidPartition(String str, int start, int end) {
        if ((end - start) >= 2) { // If the length of the string is greater than 2, it's invalid
            return false;
        }
        /*
         * Check for single digit decoding (valid if the digit is not '0')
         * A single digit can only be decoded if it is between '1' and '9'
         */
        if ((end - start) == 0) { 
            return str.charAt(start) != '0';
        }

        /*
         * Check for valid two-digit range (10 to 26)
         * Numbers between 10-19 are valid (no restrictions on the second digit)
         * Numbers between 20-26 are valid
         */
        if (str.charAt(start) == '1' || (str.charAt(start) == '2' && str.charAt(end) <= '6')) {
            return true;
        }

        return false;
    }
}

//Using backward recursive approach

class Solution {
    public int numDecodings(String str) {
        return numDecodingsHelper(str, str.length() - 1);
    }

    private int numDecodingsHelper(String str, int index) {
        if (index < 0) {
            return 1;
        }

        int count = 0;

        for (int i = index; i >= 0; i--) {
            if (isValidPartition(str, i, index)) {
                count += numDecodingsHelper(str, i - 1);
            }
        }

        return count;
    }

    private boolean isValidPartition(String str, int start, int end) {
        if ((end - start) >= 2) { // If the length of the string is greater than 2, it's invalid
            return false;
        }
        /*
         * Check for single digit decoding (valid if the digit is not '0')
         * A single digit can only be decoded if it is between '1' and '9'
         */
        if ((end - start) == 0) {
            return str.charAt(start) != '0';
        }

        /*
         * Check for valid two-digit range (10 to 26)
         * Numbers between 10-19 are valid (no restrictions on the second digit)
         * Numbers between 20-26 are valid
         */
        if (str.charAt(start) == '1' || (str.charAt(start) == '2' && str.charAt(end) <= '6')) {
            return true;
        }

        return false;
    }
}


//Good Approach

//Using forward recursive approach

class Solution {
    private int[] cache;

    public int numDecodings(String str) {
        cache = new int[str.length()];
        Arrays.fill(cache, -1);
        return numDecodingsHelper(str, 0);
    }

    private int numDecodingsHelper(String str, int start) {
        if (start == str.length()) {
            return 1;
        }

        if (cache[start] != -1) {
            return cache[start];
        }

        int count = 0;

        for (int i = start; i < str.length(); i++) {
            if (isValidPartition(str, start, i)) {
                count += numDecodingsHelper(str, i + 1);
            }
        }

        return cache[start] = count;
    }

    private boolean isValidPartition(String str, int start, int end) {
        if ((end - start) >= 2) {
            return false;
        }

        if ((end - start) == 0) {
            return str.charAt(start) != '0';
        }

        if (str.charAt(start) == '1' || (str.charAt(start) == '2' && str.charAt(end) <= '6')) {
            return true;
        }

        return false;
    }
}

//Using Backward recursive approach

class Solution {
    private int[] cache;

    public int numDecodings(String str) {
        cache = new int[str.length()];
        Arrays.fill(cache, -1);
        return numDecodingsHelper(str, str.length() - 1);
    }

    private int numDecodingsHelper(String str, int index) {
        if (index < 0) {
            return 1;
        }

        if (cache[index] != -1) {
            return cache[index];
        }

        int count = 0;

        for (int i = index; i >= 0; i--) {
            if (isValidPartition(str, i, index)) {
                count += numDecodingsHelper(str, i - 1);
            }
        }

        return cache[index] = count;
    }

    private boolean isValidPartition(String str, int start, int end) {
        if ((end - start) >= 2) {
            return false;
        }

        if ((end - start) == 0) {
            return str.charAt(start) != '0';
        }

        if (str.charAt(start) == '1' || (str.charAt(start) == '2' && str.charAt(end) <= '6')) {
            return true;
        }

        return false;
    }
}


//Better Approach

//Using forward recursive approach

class Solution {
    private int[] cache;

    public int numDecodings(String str) {
        cache = new int[str.length()];
        Arrays.fill(cache, -1);
        return numDecodingsHelper(str, 0);
    }

    private int numDecodingsHelper(String str, int index) {
        if (index == str.length()) {
            return 1;
        }

        if (cache[index] != -1) {
            return cache[index];
        }

        int count = 0;
        
        if (str.charAt(index) != '0') {
            count = numDecodingsHelper(str, index + 1);
        }

        if (isValidPartition(str, index, index + 1)) {
            count += numDecodingsHelper(str, index + 2);
        }

        return cache[index] = count;
    }

    private boolean isValidPartition(String str, int start, int end) {
        if (end == str.length()) {
            return false;
        }

        if (str.charAt(start) == '1' || (str.charAt(start) == '2' && str.charAt(end) <= '6')) {
            return true;
        }

        return false;
    }
}

//Using Backward recursive approach

class Solution {
    private int[] cache;

    public int numDecodings(String str) {
        cache = new int[str.length()];
        Arrays.fill(cache, -1);
        return numDecodingsHelper(str, str.length() - 1);
    }

    private int numDecodingsHelper(String str, int index) {
        if (index < 0) {
            return 1;
        }

        if (cache[index] != -1) {
            return cache[index];
        }

        int count = 0;

        if (str.charAt(index) != '0') {
            count = numDecodingsHelper(str, index - 1);
        }

        if (isValidPartition(str, index - 1, index)) {
            count += numDecodingsHelper(str, index - 2);
        }

        return cache[index] = count;
    }

    private boolean isValidPartition(String str, int start, int end) {
        if (start < 0) {
            return false;
        }

        if (str.charAt(start) == '1' || (str.charAt(start) == '2' && str.charAt(end) <= '6')) {
            return true;
        }

        return false;
    }
}

//Optimal Approach

class Solution {
    public int numDecodings(String str) {
        // dp[i] represents the number of ways to decode the substring str[0..i-1]
        int[] dp = new int[str.length() + 1];

        dp[0] = 1; // Base case: There's one way to decode an empty string (doing nothing)

        /*
         * Initialize dp[1] based on the first character
         * If the first character is '0', there are no valid decodings, hence dp[1] = 0
         * Otherwise, if it's between '1' and '9', it's valid and dp[1] = 1
         */
        dp[1] = str.charAt(0) != '0' ? 1 : 0;

        for (int i = 2; i <= str.length(); i++) {
            // Single-digit decoding: Only valid if the current character (str[i-1]) is not '0'
            if (str.charAt(i - 1) != '0') {
                dp[i] = dp[i - 1];
            }

            // Double-digit decoding: Check if the substring from str[i-2] to str[i-1] forms a valid number (10-26)
            if (isValidPartition(str, i - 2, i - 1)) {
                dp[i] += dp[i - 2];
            }
        }

        return dp[str.length()]; // Return the number of ways to decode the entire string
    }

    private boolean isValidPartition(String str, int start, int end) {
        // Valid if the first digit is '1' (so it could be '10' to '19'), or the first digit is '2' and the second digit is <= '6' (to ensure it's '20' to '26')
        if (str.charAt(start) == '1' || (str.charAt(start) == '2' && str.charAt(end) <= '6')) {
            return true;
        }

        return false;
    }
}


//Aliter (Space optimised)

class Solution {
    public int numDecodings(String str) {
        int previous2 = 1;
        int previous1 = str.charAt(0) != '0' ? 1 : 0;

        for (int i = 2; i <= str.length(); i++) {
            int current = 0;
            if (str.charAt(i - 1) != '0') {
                current = previous1;
            }

            if (isValidPartition(str, i - 2, i - 1)) {
                current += previous2;
            }

            previous2 = previous1;
            previous1 = current;
        }

        return previous1;
    }

    private boolean isValidPartition(String str, int start, int end) {
        if (str.charAt(start) == '1' || (str.charAt(start) == '2' && str.charAt(end) <= '6')) {
            return true;
        }

        return false;
    }
}
