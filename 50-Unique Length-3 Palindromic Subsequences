//Bruteforce Approach

class Solution {
    public int countPalindromicSubsequence(String str) {
        Set<String> uniqueSubsequencesOfLengthThree = new HashSet<>();
        StringBuilder currentSubsequence = new StringBuilder();
        int count = 0, totalSubsequences = 1 << str.length();

        for (int num = 0; num < totalSubsequences; num++) {
            for (int i = 0; i < str.length(); i++) {
                if ((num & (1 << i)) != 0) {
                    currentSubsequence.append(str.charAt(i));
                    if (currentSubsequence.length() > 3) {
                        break;
                    }
                }
            }

            String subsequence = currentSubsequence.toString();

            if (subsequence.length() == 3 && isPalindrome(subsequence) && !uniqueSubsequencesOfLengthThree.contains(subsequence)) {
                count++;
            }

            uniqueSubsequencesOfLengthThree.add(subsequence);
            currentSubsequence.setLength(0);
        }

        return count;
    }

    private boolean isPalindrome(String str) {
        return str.charAt(0) == str.charAt(2);
    }
}


//Improved Approach

class Solution {
    public int countPalindromicSubsequence(String str) {
        Set<String> uniqueSubsequencesOfLengthThree = new HashSet<>();

        for (int i = 0; i < str.length(); i++) {
            for (int j = i + 1; j < str.length(); j++) {
                for (int k = j + 1; k < str.length(); k++) {
                    String subsequence = "" + str.charAt(i) + str.charAt(j) + str.charAt(k);
                    if (isPalindrome(subsequence)) {
                        uniqueSubsequencesOfLengthThree.add(subsequence);
                    }
                }
            }
        }

        return uniqueSubsequencesOfLengthThree.size();
    }

    private boolean isPalindrome(String str) {
        return str.charAt(0) == str.charAt(2);
    }
}


//Better Approach

