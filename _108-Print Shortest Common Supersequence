/*
Why does the backward recursive approach fail when printing the Shortest Common Supersequence (SCS) but work well for the Longest Common Subsequence (LCS)?

In the case of LCS, we only print matching characters, so the backward recursion is effective as it preserves the order by definition. However, for SCS, 
we must account for both matching and non-matching characters. Working backward can result in non-matching characters being inserted incorrectly relative to the original strings,
which necessitates the use of a forward recursive approach.

To ensure accuracy when printing results for problems that involve subsequences, it is generally safer to employ a forward recursive approach. 
Conversely, if the objective is solely to determine the length of the result, a backward recursion can still be a viable option.

The backward recursive approach for computing the length of a result (such as the length of the Shortest Common Supersequence), when converted to a tabulation method, 
can also be applied in situations where printing the solution is necessary and involves subsequence concepts. After constructing the dynamic programming (DP) matrix, 
we can traverse it from the bottom up to extract and print the solution, such as the Shortest Common Supersequence.
*/

//Bruteforce Approach

class Solution {
    public String shortestCommonSupersequence(String str1, String str2) {
        return computeScs(str1, str2, 0, 0);
    }

    private String computeScs(String str1, String str2, int i, int j) {
        if (i == str1.length() && j == str2.length()) {
            return "";
        }

        if (i == str1.length()) {
            return str2.substring(j);
        }

        if (j == str2.length()) {
            return str1.substring(i);
        }

        if (str1.charAt(i) == str2.charAt(j)) {
            return str1.charAt(i) + computeScs(str1, str2, i + 1, j + 1);
        }

        String option1 = computeScs(str1, str2, i + 1, j);
        String option2 = computeScs(str1, str2, i, j + 1);

        if (option1.length() < option2.length()) {
            return str1.charAt(i) + option1;
        }

        return str2.charAt(j) + option2;
    }
}


//Optimal Approach

class Solution {
    public String shortestCommonSupersequence(String str1, String str2) {
        int[][] dp = new int[str1.length() + 1][str2.length() + 1];

        dp[0][0] = 0;

        for (int i = 1; i <= str2.length(); i++) {
            dp[0][i] = i;
        }

        for (int i = 1; i <= str1.length(); i++) {
            dp[i][0] = i;
        }

        for (int i = 1; i <= str1.length(); i++) {
            for (int j = 1; j <= str2.length(); j++) {
                if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                } else {
                    dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        int i = str1.length(), j = str2.length();
        StringBuilder shortestCommonSupersequence = new StringBuilder();

        while (i > 0 && j > 0) {
            if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
                shortestCommonSupersequence.append(str1.charAt(i - 1));
                i--;
                j--;
            } else if (dp[i - 1][j] < dp[i][j - 1]) {
                shortestCommonSupersequence.append(str1.charAt(i - 1));
                i--;
            } else {
                shortestCommonSupersequence.append(str2.charAt(j - 1));
                j--;
            }
        }

        while (i > 0) {
            shortestCommonSupersequence.append(str1.charAt(i - 1));
            i--;
        }

        while (j > 0) {
            shortestCommonSupersequence.append(str2.charAt(j - 1));
            j--;
        }

        return shortestCommonSupersequence.reverse().toString();
    }
}
