//Bruteforce Approach

class Solution {
    public String minWindow(String str, String sub) {
        Map<Character, Integer> windowFreqMap = new HashMap<>();
        Map<Character, Integer> subFreqMap = new HashMap<>();
        int minLength = Integer.MAX_VALUE, bestStart = -1, bestEnd = -1;

        for (int i = 0; i < sub.length(); i++) {
            subFreqMap.put(sub.charAt(i), subFreqMap.getOrDefault(sub.charAt(i), 0) + 1);
        }

        for (int start = 0; start < str.length(); start++) {
            for (int end = start; end < str.length(); end++) {
                windowFreqMap.put(str.charAt(end), windowFreqMap.getOrDefault(str.charAt(end), 0) + 1);

                // If the current window size is smaller than the length of the target string, skip it
                if (end - start + 1 < sub.length()) {
                    continue; // Continue to expand the window
                }

                if (containsAllChar(windowFreqMap, subFreqMap) && (end - start + 1) < minLength) {
                    minLength = end - start + 1;
                    bestStart = start;
                    bestEnd = end;
                    break; // Break out of the inner loop since further expansions will only yield larger substrings
                }
            }
            // Clear the window frequency map after finishing the current 'start' point to reset for the next window
            windowFreqMap.clear();
        }
        // If no valid window was found, return an empty string Otherwise, return the substring from the best start to best end positions
        return bestStart == -1 ? "" : str.substring(bestStart, bestEnd + 1);
    }

    private boolean containsAllChar(Map<Character, Integer> windowFreqMap, Map<Character, Integer> subFreqMap) {
        for (char ch : subFreqMap.keySet()) {
            if (!windowFreqMap.containsKey(ch) || windowFreqMap.get(ch) < subFreqMap.get(ch)) {
                return false; // If a character is missing from the window or its count is less than needed, return false
            }
        }
        // If all characters are present with the required frequencies, return true
        return true;
    }
}


//Better Approach

