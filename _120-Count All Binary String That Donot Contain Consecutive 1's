//Bruteforce Approach
/*
Note 1:
To determine the number of binary strings of length n, we need to calculate the different ways to form a string consisting of n bits, where each bit can be either 0 or 1.

Since each position in the binary string has 2 options (0 or 1), the total number of binary strings of length n can be expressed as: 2 ^ n.

Note 2:
By generating numbers from 0 to 2^n - 1 and converting each number to its binary form (while ensuring it is padded to a length of N), we capture all possible combinations of N bits.

Each bit position can be independently set to 0 or 1, and this systematic approach guarantees that every possible bit configuration is represented exactly once.
*/

class Solution {
    private static final long MOD = 1000000007L;

    long countStrings(int n) {
        long countValidNLengthBinaryStrings = 0;
        int totalNLengthBinaryStrings = 1 << n; // x<<y = x*2^n
        char[] nLengthBinaryString = new char[n];

        for (int num = 0; num < totalNLengthBinaryStrings; num++) {
            for (int i = 0; i < n; i++) {
                if ((num & (1 << i)) != 0) {
                    nLengthBinaryString[n - 1 - i] = '1';
                } else {
                    nLengthBinaryString[n - 1 - i] = '0';
                }
            }

            if (isValidBinaryString(nLengthBinaryString)) {
                countValidNLengthBinaryStrings = (countValidNLengthBinaryStrings + 1) % MOD;
            }
        }

        return countValidNLengthBinaryStrings;
    }

    private boolean isValidBinaryString(char[] arr) {
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] == '1' && arr[i] == arr[i - 1]) {
                return false;
            }
        }

        return true;
    }
}


//Improved Approach

class Solution {
    private static final long MOD = 1000000007L;

    long countStrings(int n) {
        return countValidNLengthBinaryStrings(new char[n], n - 1, false);
    }

    private long countValidNLengthBinaryStrings(char[] currentNLengthBinaryString, int index, boolean wasLastBitOne) {
        if (index < 0) {
            return 1L;
        }

        // Place '0' at the current index
        currentNLengthBinaryString[index] = '0';
        long count = countValidNLengthBinaryStrings(currentNLengthBinaryString, index - 1, false);

        // Place '1' at the current index only if the previous bit is not '1'
        if (!wasLastBitOne) {
            currentNLengthBinaryString[index] = '1';
            count = (count + countValidNLengthBinaryStrings(currentNLengthBinaryString, index - 1, true)) % MOD;
        }

        return count;
    }
}


//Good Approach

class Solution {
    private static final long MOD = 1000000007L;

    long countStrings(int n) {
        return countValidNLengthBinaryStrings(n-1, false);
    }

    private long countValidNLengthBinaryStrings(int index, boolean wasLastBitOne) {
        if (index < 0) {
            return 1L;
        }

        // Place '0' at the current index
        long count = countValidNLengthBinaryStrings(index - 1, false);

        // Place '1' at the current index only if the previous bit is not '1'
        if (!wasLastBitOne) {
            count = (count + countValidNLengthBinaryStrings(index - 1, true)) % MOD;
        }

        return count;
    }
}


//Better Approach

class Solution {
    private static final long MOD = 1000000007L;
    private long[][] cache;

    long countStrings(int n) {
        cache = new long[n][2];
        intializeCache();
        return countValidNLengthBinaryStrings(n - 1, 0);
    }

    private long countValidNLengthBinaryStrings(int index, int wasLastBitOne) {
        if (index < 0) {
            return 1L;
        }

        if (cache[index][wasLastBitOne] != -1) {
            return cache[index][wasLastBitOne];
        }

        long count = countValidNLengthBinaryStrings(index - 1, 0);

        if (wasLastBitOne == 0) {
            count = (count + countValidNLengthBinaryStrings(index - 1, 1)) % MOD;
        }

        return cache[index][wasLastBitOne] = count;
    }

    private void intializeCache() {
        for (int i = 0; i < cache.length; i++) {
            Arrays.fill(cache[i], -1);
        }
    }
}


//Optimal Approach

class Solution {
    private static final long MOD = 1000000007L;

    long countStrings(int n) {
        /*
         * dp[i][0] -> Count of valid strings of length i ending with '0'
         * dp[i][1] -> Count of valid strings of length i ending with '1'
         */
        long[][] dp = new long[n + 1][2];

        // Base case: An empty string can be considered as both ending with '0' and '1'
        dp[0][0] = 1L;
        dp[0][1] = 1L;

        for (int index = 1; index <= n; index++) {
            for (int wasLastBitOne = 0; wasLastBitOne <= 1; wasLastBitOne++) {
                long count = dp[index - 1][0];
                if (wasLastBitOne == 0) {
                    count = (count + dp[index - 1][1]) % MOD;
                }

                dp[index][wasLastBitOne] = count;
            }
        }

        return dp[n][0];
    }
}


//Aliter (Space optimised)

class Solution {
    private static final long MOD = 1000000007L;

    long countStrings(int n) {
        long[] previousRow=new long[2];
        long[] currentRow=new long[2];

        previousRow[0]=1L;
        previousRow[1]=1L;
        
        for(int index=1;index<=n;index++){
            for(int wasLastBitOne=0;wasLastBitOne<=1;wasLastBitOne++){
              long count=previousRow[0];
              if(wasLastBitOne==0){
                  count=(count+previousRow[1])%MOD;
              }
               
              currentRow[wasLastBitOne]=count;
            }
            long[] temp=currentRow;
            currentRow=previousRow;
            previousRow=temp;
        }
        
        return previousRow[0];
    }
}
