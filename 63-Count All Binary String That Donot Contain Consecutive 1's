//Bruteforce Approach

/*
Note 1:
To determine the number of binary strings of length n, we need to calculate the different ways to form a string consisting of n bits, where each bit can be either 0 or 1.

Since each position in the binary string has 2 options (0 or 1), the total number of binary strings of length n can be expressed as: 2 ^ n.

Note 2:
By generating numbers from 0 to 2^n - 1 and converting each number to its binary form (while ensuring it is padded to a length of N), we capture all possible combinations of N bits.

Each bit position can be independently set to 0 or 1, and this systematic approach guarantees that every possible bit configuration is represented exactly once.
*/

class Solution {
    private static final long MOD = 1000000007L;

    long countStrings(int n) {
        long countValidNLengthBinaryStrings = 0;
        int totalNLengthBinaryStrings = 1 << n; // x<<y = x*2^n
        char[] nLengthBinaryString = new char[n];

        for (int num = 0; num < totalNLengthBinaryStrings; num++) {
            for (int i = 0; i < n; i++) {
                if ((num & (1 << i)) != 0) {
                    nLengthBinaryString[n - 1 - i] = '1';
                } else {
                    nLengthBinaryString[n - 1 - i] = '0';
                }
            }

            if (isValidBinaryString(nLengthBinaryString)) {
                countValidNLengthBinaryStrings = (countValidNLengthBinaryStrings + 1) % MOD;
            }
        }

        return countValidNLengthBinaryStrings;
    }

    private boolean isValidBinaryString(char[] arr) {
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] == '1' && arr[i] == arr[i - 1]) {
                return false;
            }
        }

        return true;
    }
}


//Better Approach

class Solution {
    private long countValidNLengthBinaryStrings = 0;
    private static final long MOD = 1000000007L;

    long countStrings(int n) {
        countValidNLengthBinaryStrings(new char[n], 0);
        return countValidNLengthBinaryStrings;
    }

    private void countValidNLengthBinaryStrings(char[] currentNLengthBinaryString, int index) {
        if (index == currentNLengthBinaryString.length) {
            countValidNLengthBinaryStrings = (countValidNLengthBinaryStrings + 1) % MOD;
            return;
        }
        
        // Place '0' at the current index
        currentNLengthBinaryString[index] = '0';
        countValidNLengthBinaryStrings(currentNLengthBinaryString, index + 1);

        // Place '1' at the current index only if the previous bit is not '1'
        if (index == 0 || (index > 0 && currentNLengthBinaryString[index - 1] != '1')) {
            currentNLengthBinaryString[index] = '1';
            countValidNLengthBinaryStrings(currentNLengthBinaryString, index + 1);
        }
    }
}


//Aliter

class Solution {
    private static final long MOD = 1000000007L;

    long countStrings(int n) {
        return countValidNLengthBinaryStrings(new char[n], 0, false);
    }

    private long countValidNLengthBinaryStrings(char[] currentNLengthBinaryString, int index, boolean wasLastBitOne) {
        if (index == currentNLengthBinaryString.length) {
            return 1L;
        }

        currentNLengthBinaryString[index] = '0';
        long count = countValidNLengthBinaryStrings(currentNLengthBinaryString, index + 1, false);

        if (!wasLastBitOne) {
            currentNLengthBinaryString[index] = '1';
            count = (count + countValidNLengthBinaryStrings(currentNLengthBinaryString, index + 1, true)) % MOD;
        }

        return count;
    }
}


//Optimal Approach

//Naive Implementation

class Solution {
    private static final long MOD = 1000000007L;

    long countStrings(int n) {
        // endWithZero[i] = count of binary substring of length 'i' that ends with 0
        long[] endWithZero = new long[n + 1];
        // endWithOne[i] = count of binary substring of length 'i' that ends with 1
        long[] endWithOne = new long[n + 1];

        // Base case: There is one binary string of length 1 ending with 0 ("0")
        endWithZero[1] = 1;
        // Base case: There is one binary string of length 1 ending with 1 ("1")
        endWithOne[1] = 1;

        for (int i = 2; i <= n; i++) {
            /*
             * A binary string of length i that ends with 0 can be formed by appending 0 to
             * any binary string of length i-1 that ends with '0' or '1'.
             */
            endWithZero[i] = (endWithZero[i - 1] + endWithOne[i - 1]) % MOD;
            /*
             * A valid binary string(that donot contain consecutive 1's) of length i that
             * ends with '1' can only be formed by appending '1' to any binary string of
             * length i-1 that ends with '0'.
             */
            endWithOne[i] = endWithZero[i - 1];
        }
        /*
         * The total number of valid binary strings of length 'n' is the sum of the
         * numbers of binary strings of length 'n' ending with '0' and ending with '1'
         * (without consecutive 1's).
         */
        return (endWithZero[n] + endWithOne[n]) % MOD;
    }
}


//Optimal Implementation
/*
Intuition :
In the above implementation we can clearly see that  we are only required to keep track of 'previous end With zero count', 
'previous End with one count', 'current end with zero count' and 'current end with one count' 
hence we can make use of 4 variables to denote those state eliminating the need of two 1D array's 
thus reducing the space complexity of the algorithm can be reduced from O(n) to O(1).
*/

class Solution {
    private static final long MOD = 1000000007L;

    long countStrings(int length) {
        long countEndingWithZeroPrev, countEndingWithOnePrev, countEndingWithZeroCurr, countEndingWithOneCurr;
        
        // Initialize counts for strings of length 1
        countEndingWithZeroPrev = countEndingWithOnePrev = 1;

        for (int i = 2; i <= length; i++) {
            // Current counts for strings of length i
            countEndingWithZeroCurr = (countEndingWithZeroPrev + countEndingWithOnePrev) % MOD;
            countEndingWithOneCurr = countEndingWithZeroPrev;

            // Update previous counts for the next iteration
            countEndingWithZeroPrev = countEndingWithZeroCurr;
            countEndingWithOnePrev = countEndingWithOneCurr;
        }

        // Return the total count of valid binary strings of the given length
        return (countEndingWithZeroPrev + countEndingWithOnePrev) % MOD;
    }
}
