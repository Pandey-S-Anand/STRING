//Optimal Approach

class Solution {
    private int mod = 1000000007;

    public int countPalindromicSubsequences(String str) {
        int[][] dp = new int[str.length()][str.length()];
        int[] nextOccurenceIndex = new int[str.length()];
        int[] prevOccurenceIndex = new int[str.length()];
        Map<Character, Integer> map = new HashMap<>();

        for (int i = 0; i < str.length(); i++) {
            char ch = str.charAt(i);
            if (map.containsKey(ch)) {
                prevOccurenceIndex[i] = map.get(ch);
            } else {
                prevOccurenceIndex[i] = -1;
            }

            map.put(ch, i);
        }

        map.clear();

        for (int i = str.length() - 1; i >= 0; i--) {
            char ch = str.charAt(i);
            if (map.containsKey(ch)) {
                nextOccurenceIndex[i] = map.get(ch);
            } else {
                nextOccurenceIndex[i] = -1;
            }

            map.put(ch, i);
        }
        
        // dp[i][j] = count of distinct palindromic subsequences in the substring str[i...j]
        for (int gap = 0; gap < str.length(); gap++) {
            for (int i = 0, j = gap; j < str.length(); i++, j++) {
                if (gap == 0) {
                    dp[i][j] = 1;// A single character is a palindrome of length 1
                } else if (gap == 1) {
                    dp[i][j] = 2;// If chars are different, count both individually. If same, count one character and the pair as palindrome.
                } else {
                    if (str.charAt(i) != str.charAt(j)) {
                        dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1];
                    } else { // str.charAt(i)==str.charAt(j) = ch (say)
                        int nextIndex = nextOccurenceIndex[i]; // Next occurence of ch after i
                        int prevIndex = prevOccurenceIndex[j]; // Previous occurence of ch before j

                        if (nextIndex > prevIndex) { // Means no occurence of ch in middle part
                            dp[i][j] = 2 * dp[i + 1][j - 1] + 2;
                        } else if (nextIndex == prevIndex) { // Means only one occurence of ch in middle part
                            dp[i][j] = 2 * dp[i + 1][j - 1] + 1;
                        } else {// nextIndex < prevIndex => Means than one occurences of ch in middle part
                            dp[i][j] = 2 * dp[i + 1][j - 1] - dp[nextIndex + 1][prevIndex - 1];
                        }
                    }
                }

                // Handle modulo
                if (dp[i][j] < 0) {
                    dp[i][j] = dp[i][j] + mod;
                } else {
                    dp[i][j] = dp[i][j] % mod;
                }
            }
        }

        return dp[0][str.length() - 1];
    }
}
